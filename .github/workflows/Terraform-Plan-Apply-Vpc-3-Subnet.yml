name: Terraform-Apply-AWS-VPC-3-Subnets
on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual triggering

permissions:
  id-token: write  # Required for AWS OIDC connection
  contents: read   # Required for actions/checkout

env:
  TF_LOG: INFO
  AWS_REGION: ${{ secrets.AWS_REGION }}
  TERRAFORM_VERSION: ${{ secrets.TERRAFORM_VERSION }}
  TF_WORKING_DIR: infrastructure

jobs:
  # PHASE 1: PREPARE
  prepare:
    name: 'ğŸ” Prepare Environment'
    runs-on: ubuntu-latest
    outputs:
      environment_ready: ${{ steps.env_check.outputs.environment_ready }}
    
    steps:
      - name: ğŸ” Checkout repository
        uses: actions/checkout@v4
      
      - name: ğŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions
      
      - name: âœ… Verify Environment
        id: env_check
        run: |
          echo "Verifying environment setup..."
          terraform --version
          aws sts get-caller-identity
          echo "environment_ready=true" >> $GITHUB_OUTPUT

  # PHASE 2: VALIDATE
  validate:
    name: 'ğŸ§ª Validate Infrastructure'
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.environment_ready == 'true'
    outputs:
      validate_status: ${{ steps.validate.outputs.validate_status }}
    
    steps:
      - name: ğŸ” Checkout repository
        uses: actions/checkout@v4
      
      - name: ğŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions
      
      - name: ğŸš€ Initialize Terraform
        id: init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "::group::Terraform Initialization"
          echo "ğŸ”„ Starting Terraform initialization..."
          
          # Initialize with state migration enabled
          if terraform init -migrate-state; then
            echo "âœ… Terraform initialization successful"
            echo "init_status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Terraform initialization failed"
            echo "init_status=failure" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "::endgroup::"

      - name: ğŸ” Validate Terraform Configuration
        id: validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        if: steps.init.outputs.init_status == 'success'
        run: |
          echo "::group::Terraform Validation"
          echo "ğŸ”„ Validating Terraform configuration..."
          
          # Validate Terraform configuration
          if terraform validate; then
            echo "âœ… Terraform validation successful"
            echo "validate_status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Terraform validation failed"
            echo "validate_status=failure" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "::endgroup::"

  # PHASE 3: PLAN
  plan:
    name: 'ğŸ“ Plan Infrastructure Changes'
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.validate_status == 'success'
    outputs:
      plan_status: ${{ steps.plan.outputs.plan_status }}
      resources_add: ${{ steps.plan_analysis.outputs.resources_add }}
      resources_change: ${{ steps.plan_analysis.outputs.resources_change }}
      resources_destroy: ${{ steps.plan_analysis.outputs.resources_destroy }}
    
    steps:
      - name: ğŸ” Checkout repository
        uses: actions/checkout@v4
      
      - name: ğŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions
      
      - name: ğŸš€ Initialize Terraform
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init -migrate-state
      
      - name: ğŸ“ Create Terraform Plan
        id: plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "::group::Terraform Plan Generation"
          echo "ğŸ”„ Generating Terraform plan..."

          # Create plan directory
          mkdir -p ./plans

          # Run plan and capture output while also displaying it
          terraform plan -out=./plans/tfplan.binary -detailed-exitcode -input=false -no-color 2>&1 | tee ./plans/plan_output.txt
          PLAN_EXIT_CODE=${PIPESTATUS[0]}

          echo "âœ… Terraform plan generated with exit code: ${PLAN_EXIT_CODE}"
          echo "plan_status=success" >> $GITHUB_OUTPUT
          
          # Also extract detailed resource changes for human-readable output
          terraform show -no-color ./plans/tfplan.binary > ./plans/tfplan_details.txt
          
          echo "::endgroup::"
      
      - name: ğŸ“Š Analyze Plan Results
        id: plan_analysis
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "::group::Plan Analysis"
          
          # Extract the Plan summary line from the output
          PLAN_SUMMARY=$(grep "Plan:" ./plans/plan_output.txt | head -1 || echo "Plan: 0 to add, 0 to change, 0 to destroy")
          echo "Plan summary: ${PLAN_SUMMARY}"
          
          # Extract the numbers using sed for better precision
          RESOURCES_ADD=$(echo "${PLAN_SUMMARY}" | sed -n 's/.*Plan: \([0-9]\+\) to add.*/\1/p' || echo "0")
          RESOURCES_CHANGE=$(echo "${PLAN_SUMMARY}" | sed -n 's/.*\([0-9]\+\) to change.*/\1/p' || echo "0")
          RESOURCES_DESTROY=$(echo "${PLAN_SUMMARY}" | sed -n 's/.*\([0-9]\+\) to destroy.*/\1/p' || echo "0")
          
          # Ensure the values are clean integers
          RESOURCES_ADD=$(echo "${RESOURCES_ADD}" | tr -d ' \n\r' || echo "0")
          [ -z "${RESOURCES_ADD}" ] && RESOURCES_ADD="0"
          RESOURCES_CHANGE=$(echo "${RESOURCES_CHANGE}" | tr -d ' \n\r' || echo "0") 
          [ -z "${RESOURCES_CHANGE}" ] && RESOURCES_CHANGE="0"
          RESOURCES_DESTROY=$(echo "${RESOURCES_DESTROY}" | tr -d ' \n\r' || echo "0")
          [ -z "${RESOURCES_DESTROY}" ] && RESOURCES_DESTROY="0"
          
          echo "Resources to add: ${RESOURCES_ADD}"
          echo "Resources to change: ${RESOURCES_CHANGE}"
          echo "Resources to destroy: ${RESOURCES_DESTROY}"
          
          # Report to job outputs
          echo "resources_add=${RESOURCES_ADD}" >> $GITHUB_OUTPUT
          echo "resources_change=${RESOURCES_CHANGE}" >> $GITHUB_OUTPUT
          echo "resources_destroy=${RESOURCES_DESTROY}" >> $GITHUB_OUTPUT
          
          # Create a detailed breakdown file
          echo "# Terraform Plan Analysis" > ./plans/plan_breakdown.md
          echo "## Summary" >> ./plans/plan_breakdown.md
          echo "ğŸŸ¢ Resources to add: ${RESOURCES_ADD}" >> ./plans/plan_breakdown.md
          echo "ğŸŸ  Resources to change: ${RESOURCES_CHANGE}" >> ./plans/plan_breakdown.md
          echo "ğŸ”´ Resources to destroy: ${RESOURCES_DESTROY}" >> ./plans/plan_breakdown.md
          echo "" >> ./plans/plan_breakdown.md
          
          # Extract resource names and types from the plan
          echo "## Detailed Resource Changes" >> ./plans/plan_breakdown.md
          
          # Resources to add
          echo "### Resources to be created:" >> ./plans/plan_breakdown.md
          grep -A 1 "# .* will be created" ./plans/plan_output.txt | grep -v "will be created" | grep -v -- "^--$" | sed 's/^[[:space:]]*/- /' >> ./plans/plan_breakdown.md || echo "None" >> ./plans/plan_breakdown.md
          echo "" >> ./plans/plan_breakdown.md
          
          # Resources to change
          echo "### Resources to be modified:" >> ./plans/plan_breakdown.md
          grep -A 1 "# .* will be updated in-place" ./plans/plan_output.txt | grep -v "will be updated in-place" | grep -v -- "^--$" | sed 's/^[[:space:]]*/- /' >> ./plans/plan_breakdown.md || echo "None" >> ./plans/plan_breakdown.md
          echo "" >> ./plans/plan_breakdown.md
          
          # Resources to destroy
          echo "### Resources to be destroyed:" >> ./plans/plan_breakdown.md
          grep -A 1 "# .* will be destroyed" ./plans/plan_output.txt | grep -v "will be destroyed" | grep -v -- "^--$" | sed 's/^[[:space:]]*/- /' >> ./plans/plan_breakdown.md || echo "None" >> ./plans/plan_breakdown.md
          
          echo "âœ… Plan analysis complete"
          echo "::endgroup::"

      - name: ğŸ“ Upload Plan Artifacts
        uses: actions/upload-artifact@v4
        if: steps.plan.outputs.plan_status == 'success'
        with:
          name: terraform-plans
          path: ${{ env.TF_WORKING_DIR }}/plans/
          retention-days: 5

  # PHASE 4: APPLY
  apply:
    name: 'ğŸš€ Apply Infrastructure Changes'
    runs-on: ubuntu-latest
    needs: plan
    if: needs.plan.outputs.plan_status == 'success'
    outputs:
      apply_status: ${{ steps.apply.outputs.apply_status }}
      applied_resources: ${{ steps.apply_analysis.outputs.applied_resources }}
      vpc_id: ${{ steps.terraform_outputs.outputs.vpc_id }}
      vpc_cidr: ${{ steps.terraform_outputs.outputs.vpc_cidr }}
      subnet_1_id: ${{ steps.terraform_outputs.outputs.subnet_1_id }}
      subnet_1_cidr: ${{ steps.terraform_outputs.outputs.subnet_1_cidr }}
      subnet_2_id: ${{ steps.terraform_outputs.outputs.subnet_2_id }}
      subnet_2_cidr: ${{ steps.terraform_outputs.outputs.subnet_2_cidr }}
      subnet_3_id: ${{ steps.terraform_outputs.outputs.subnet_3_id }}
      subnet_3_cidr: ${{ steps.terraform_outputs.outputs.subnet_3_cidr }}
      internet_gateway_id: ${{ steps.terraform_outputs.outputs.internet_gateway_id }}
      route_table_id: ${{ steps.terraform_outputs.outputs.route_table_id }}
    
    steps:
      - name: ğŸ” Checkout repository
        uses: actions/checkout@v4
      
      - name: ğŸ”§ Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: ğŸ” Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-TerraformApply
      
      - name: ğŸš€ Initialize Terraform
        id: init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "::group::Terraform Initialization"
          echo "ğŸ”„ Starting Terraform initialization..."
          
          if terraform init -migrate-state; then
            echo "âœ… Terraform initialization successful"
          else
            echo "âŒ Terraform initialization failed"
            exit 1
          fi
          echo "::endgroup::"
      
      - name: ğŸ”„ Apply Terraform Changes
        id: apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "::group::Terraform Apply"
          echo "ğŸ”„ Applying Terraform changes..."
          
          # Create apply directory
          mkdir -p ./apply_results
          
          # Run apply and capture output
          terraform apply -auto-approve -no-color 2>&1 | tee ./apply_results/apply_output.txt
          APPLY_EXIT_CODE=${PIPESTATUS[0]}
          
          if [ $APPLY_EXIT_CODE -eq 0 ]; then
            echo "âœ… Terraform apply successful"
            echo "apply_status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Terraform apply failed"
            echo "apply_status=failure" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "::endgroup::"
      
      - name: ğŸ“‹ Capture Terraform Outputs
        id: terraform_outputs
        working-directory: ${{ env.TF_WORKING_DIR }}
        if: steps.apply.outputs.apply_status == 'success'
        run: |
          echo "::group::Terraform Outputs"
          # Capture VPC info
          VPC_ID=$(terraform output -raw vpc_id || echo "N/A")
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          VPC_CIDR=$(terraform output -raw vpc_cidr || echo "N/A")
          echo "vpc_cidr=$VPC_CIDR" >> $GITHUB_OUTPUT
          
          # Capture subnet info
          SUBNET_1_ID=$(terraform output -raw subnet_1_id || echo "N/A")
          echo "subnet_1_id=$SUBNET_1_ID" >> $GITHUB_OUTPUT
          SUBNET_1_CIDR=$(terraform output -raw subnet_1_cidr || echo "N/A")
          echo "subnet_1_cidr=$SUBNET_1_CIDR" >> $GITHUB_OUTPUT
          
          SUBNET_2_ID=$(terraform output -raw subnet_2_id || echo "N/A")
          echo "subnet_2_id=$SUBNET_2_ID" >> $GITHUB_OUTPUT
          SUBNET_2_CIDR=$(terraform output -raw subnet_2_cidr || echo "N/A")
          echo "subnet_2_cidr=$SUBNET_2_CIDR" >> $GITHUB_OUTPUT
          
          SUBNET_3_ID=$(terraform output -raw subnet_3_id || echo "N/A")
          echo "subnet_3_id=$SUBNET_3_ID" >> $GITHUB_OUTPUT
          SUBNET_3_CIDR=$(terraform output -raw subnet_3_cidr || echo "N/A")
          echo "subnet_3_cidr=$SUBNET_3_CIDR" >> $GITHUB_OUTPUT
          
          # Capture other resources
          IGW_ID=$(terraform output -raw internet_gateway_id || echo "N/A")
          echo "internet_gateway_id=$IGW_ID" >> $GITHUB_OUTPUT
          
          RT_ID=$(terraform output -raw route_table_id || echo "N/A")
          echo "route_table_id=$RT_ID" >> $GITHUB_OUTPUT
          echo "::endgroup::"
      
      - name: ğŸ“Š Analyze Apply Results
        id: apply_analysis
        working-directory: ${{ env.TF_WORKING_DIR }}
        if: steps.apply.outputs.apply_status == 'success'
        run: |
          echo "::group::Apply Analysis"
          
          # Run terraform state list to get current resources
          terraform state list > ./apply_results/current_state.txt
          
          # Debug output - show raw content and line count
          echo "Debug - state file content:"
          cat ./apply_results/current_state.txt
          
          # Get an accurate count by explicitly counting lines
          RESOURCE_COUNT=$(grep -c ^ ./apply_results/current_state.txt || echo "0")
          
          echo "Total resources in state: ${RESOURCE_COUNT}"
          echo "applied_resources=${RESOURCE_COUNT}" >> $GITHUB_OUTPUT
          
          # Create a detailed breakdown of current state
          echo "# Terraform Apply Results" > ./apply_results/apply_breakdown.md
          echo "## Current Infrastructure State" >> ./apply_results/apply_breakdown.md
          echo "Total resources managed: ${RESOURCE_COUNT}" >> ./apply_results/apply_breakdown.md
          echo "" >> ./apply_results/apply_breakdown.md
          
          echo "## Resources By Type" >> ./apply_results/apply_breakdown.md
          # Group resources by type and count them
          if [ -s ./apply_results/current_state.txt ]; then
            # Use a more reliable method to group by resource type
            echo "Resource types breakdown:" >> ./apply_results/apply_breakdown.md
            awk -F. '{print $1}' ./apply_results/current_state.txt | sort | uniq -c | while read count type; do
              echo "- **${type}**: ${count}" >> ./apply_results/apply_breakdown.md
            done
          else
            echo "- No resources found in state" >> ./apply_results/apply_breakdown.md
          fi
          
          echo "" >> ./apply_results/apply_breakdown.md
          
          echo "## Complete Resource List" >> ./apply_results/apply_breakdown.md
          if [ -s ./apply_results/current_state.txt ]; then
            cat ./apply_results/current_state.txt | sed 's/^/- /' >> ./apply_results/apply_breakdown.md
          else
            echo "- No resources found in state" >> ./apply_results/apply_breakdown.md
          fi
          
          # Also capture output attributes of key resources
          echo "" >> ./apply_results/apply_breakdown.md
          echo "## Key Infrastructure Details" >> ./apply_results/apply_breakdown.md
          
          # Get VPC ID and CIDR if exists
          if grep -q "aws_vpc" ./apply_results/current_state.txt; then
            echo "### VPC Information" >> ./apply_results/apply_breakdown.md
            VPC_RESOURCE=$(grep "aws_vpc" ./apply_results/current_state.txt | head -1)
            echo "VPC Resource: ${VPC_RESOURCE}" >> ./apply_results/apply_breakdown.md
            terraform state show "${VPC_RESOURCE}" | grep -E 'id|cidr_block|tags' >> ./apply_results/apply_breakdown.md
            echo "" >> ./apply_results/apply_breakdown.md
          fi
          
          # Get Subnet details if they exist
          if grep -q "aws_subnet" ./apply_results/current_state.txt; then
            echo "### Subnet Information" >> ./apply_results/apply_breakdown.md
            grep "aws_subnet" ./apply_results/current_state.txt | while read subnet; do
              echo "#### ${subnet}" >> ./apply_results/apply_breakdown.md
              terraform state show "${subnet}" | grep -E 'id|cidr_block|availability_zone|vpc_id' >> ./apply_results/apply_breakdown.md
              echo "" >> ./apply_results/apply_breakdown.md
            done
          fi
          
          echo "âœ… Apply analysis complete"
          echo "::endgroup::"
      - name: ğŸ“ Upload Apply Results
        uses: actions/upload-artifact@v4
        if: steps.apply.outputs.apply_status == 'success'
        with:
          name: terraform-apply-results
          path: ${{ env.TF_WORKING_DIR }}/apply_results/
          retention-days: 5

  # PHASE 5: NOTIFICATION
  notify:
    name: 'ğŸ“¢ Send Notifications'
    runs-on: ubuntu-latest
    needs: [prepare, validate, plan, apply]
    if: always()
    
    steps:
      - name: ğŸ“Š Workflow Summary
        run: |
          echo "## Terraform Workflow Summary" > $GITHUB_STEP_SUMMARY
          echo "ğŸ“… Run completed at: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Status by Phase:" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ” Prepare: ${{ needs.prepare.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ§ª Validate: ${{ needs.validate.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“ Plan: ${{ needs.plan.result }}" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.plan.result }}" == "success" ]]; then
            echo "  - ğŸŸ¢ Resources to add: ${{ needs.plan.outputs.resources_add || '0' }}" >> $GITHUB_STEP_SUMMARY
            echo "  - ğŸŸ  Resources to change: ${{ needs.plan.outputs.resources_change || '0' }}" >> $GITHUB_STEP_SUMMARY
            echo "  - ğŸ”´ Resources to destroy: ${{ needs.plan.outputs.resources_destroy || '0' }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "- ğŸš€ Apply: ${{ needs.apply.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.apply.result }}" == "success" ]]; then
            echo "  - ğŸ—ï¸ Total resources in state: ${{ needs.apply.outputs.applied_resources || 'unknown' }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.apply.result }}" == "success" ]]; then
            echo "### ğŸŸ¢ Infrastructure Successfully Updated" >> $GITHUB_STEP_SUMMARY
            echo "The Terraform infrastructure has been successfully applied." >> $GITHUB_STEP_SUMMARY
            
            # If we have resource counts, show them
            if [[ -n "${{ needs.plan.outputs.resources_add }}" ]] || [[ -n "${{ needs.plan.outputs.resources_change }}" ]] || [[ -n "${{ needs.plan.outputs.resources_destroy }}" ]]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "#### Changes Applied:" >> $GITHUB_STEP_SUMMARY
              
              # Only show non-zero resource counts
              if [[ "${{ needs.plan.outputs.resources_add }}" != "0" ]]; then
                echo "- âœ… Added: ${{ needs.plan.outputs.resources_add }} resources" >> $GITHUB_STEP_SUMMARY
              fi
              
              if [[ "${{ needs.plan.outputs.resources_change }}" != "0" ]]; then
                echo "- ğŸ”„ Modified: ${{ needs.plan.outputs.resources_change }} resources" >> $GITHUB_STEP_SUMMARY
              fi
              
              if [[ "${{ needs.plan.outputs.resources_destroy }}" != "0" ]]; then
                echo "- ğŸ—‘ï¸ Destroyed: ${{ needs.plan.outputs.resources_destroy }} resources" >> $GITHUB_STEP_SUMMARY
              fi
              
              if [[ "${{ needs.plan.outputs.resources_add }}" == "0" ]] && [[ "${{ needs.plan.outputs.resources_change }}" == "0" ]] && [[ "${{ needs.plan.outputs.resources_destroy }}" == "0" ]]; then
                echo "- No changes were needed" >> $GITHUB_STEP_SUMMARY
              fi
            fi
            
            # Add Infrastructure Output Variables
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ğŸ” Infrastructure Output Variables" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "#### VPC Details" >> $GITHUB_STEP_SUMMARY
            echo "- **VPC ID**: \`${{ needs.apply.outputs.vpc_id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **VPC CIDR**: \`${{ needs.apply.outputs.vpc_cidr }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "#### Subnet Details" >> $GITHUB_STEP_SUMMARY
            echo "| Subnet | ID | CIDR Block |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|----|-----------:|" >> $GITHUB_STEP_SUMMARY
            echo "| Subnet 1 | \`${{ needs.apply.outputs.subnet_1_id }}\` | \`${{ needs.apply.outputs.subnet_1_cidr }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Subnet 2 | \`${{ needs.apply.outputs.subnet_2_id }}\` | \`${{ needs.apply.outputs.subnet_2_cidr }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Subnet 3 | \`${{ needs.apply.outputs.subnet_3_id }}\` | \`${{ needs.apply.outputs.subnet_3_cidr }}\` |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "#### Network Resources" >> $GITHUB_STEP_SUMMARY
            echo "- **Internet Gateway**: \`${{ needs.apply.outputs.internet_gateway_id }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Route Table**: \`${{ needs.apply.outputs.route_table_id }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ğŸ”´ Workflow Completed with Issues" >> $GITHUB_STEP_SUMMARY
            echo "Please check the job logs for details on what went wrong." >> $GITHUB_STEP_SUMMARY
          fi

      - name: ğŸ“Š Send Detailed Results
        id: send_results
        if: needs.plan.outputs.resources_add != '0' || needs.plan.outputs.resources_change != '0' || needs.plan.outputs.resources_destroy != '0'
        run: |
          # For Slack/Teams/Email notifications, prepare a rich message
          cat << EOF > terraform_report.txt
          # Terraform Infrastructure Update Report
          
          ## Overview
          - Workflow completed at: $(date)
          - Status: ${{ (needs.apply.result == 'success') && 'SUCCESS âœ…' || 'FAILED âŒ' }}
          
          ## Resource Changes
          - ğŸŸ¢ Added: ${{ needs.plan.outputs.resources_add }} resources
          - ğŸŸ  Modified: ${{ needs.plan.outputs.resources_change }} resources
          - ğŸ”´ Destroyed: ${{ needs.plan.outputs.resources_destroy }} resources
          - ğŸ—ï¸ Total resources in state: ${{ needs.apply.outputs.applied_resources || 'unknown' }}
          
          ## Infrastructure Details
          VPC with 3 public subnets was successfully deployed in AWS.
          
          ### VPC Information
          - VPC ID: ${{ needs.apply.outputs.vpc_id }}
          - VPC CIDR: ${{ needs.apply.outputs.vpc_cidr }}
          
          ### Subnet Information
          | Subnet | ID | CIDR Block |
          |--------|----|-----------:|
          | Subnet 1 | ${{ needs.apply.outputs.subnet_1_id }} | ${{ needs.apply.outputs.subnet_1_cidr }} |
          | Subnet 2 | ${{ needs.apply.outputs.subnet_2_id }} | ${{ needs.apply.outputs.subnet_2_cidr }} |
          | Subnet 3 | ${{ needs.apply.outputs.subnet_3_id }} | ${{ needs.apply.outputs.subnet_3_cidr }} |
          
          ### Network Resources
          - Internet Gateway: ${{ needs.apply.outputs.internet_gateway_id }}
          - Route Table: ${{ needs.apply.outputs.route_table_id }}
          
          ## Next Steps
          Review the full deployment report in GitHub Actions.
          EOF
          
          # Send a notification (mock for now - replace with actual implementation)
          echo "ğŸ“¨ Would send notification with the following content:"
          cat terraform_report.txt
          echo "âœ… Results prepared for notification"

      - name: ğŸ“¢ Notify on Success
        if: needs.apply.result == 'success'
        run: |
          echo "::group::Notification"
          echo "âœ… Workflow completed successfully!"
          
          echo "## ğŸš€ Infrastructure Successfully Updated"
          echo "The Terraform infrastructure has been successfully applied."
          
          # Show resource changes
          echo "### Resource Changes:"
          echo "ğŸŸ¢ Added: ${{ needs.plan.outputs.resources_add || '0' }} resources"
          echo "ğŸŸ  Modified: ${{ needs.plan.outputs.resources_change || '0' }} resources"
          echo "ğŸ”´ Destroyed: ${{ needs.plan.outputs.resources_destroy || '0' }} resources"
          echo "ğŸ—ï¸ Total resources in state: ${{ needs.apply.outputs.applied_resources || 'unknown' }}"
          
          # Show infrastructure details
          echo "### Infrastructure Details"
          echo "VPC ID: ${{ needs.apply.outputs.vpc_id }}"
          echo "VPC CIDR: ${{ needs.apply.outputs.vpc_cidr }}"
          echo "Subnet 1: ${{ needs.apply.outputs.subnet_1_id }} (${{ needs.apply.outputs.subnet_1_cidr }})"
          echo "Subnet 2: ${{ needs.apply.outputs.subnet_2_id }} (${{ needs.apply.outputs.subnet_2_cidr }})"
          echo "Subnet 3: ${{ needs.apply.outputs.subnet_3_id }} (${{ needs.apply.outputs.subnet_3_cidr }})"
          echo "Internet Gateway: ${{ needs.apply.outputs.internet_gateway_id }}"
          echo "Route Table: ${{ needs.apply.outputs.route_table_id }}"
          
          echo "Completed at: $(date)"
          echo "::endgroup::"
          echo "âœ… Notification sent"
      - name: ğŸ“¢ Notify on Failure
        if: |
          needs.prepare.result == 'failure' || 
          needs.validate.result == 'failure' || 
          needs.plan.result == 'failure' || 
          needs.apply.result == 'failure'
        run: |
          echo "::group::Notification"
          echo "âŒ Workflow failed!"
          
          if [[ "${{ needs.prepare.result }}" == "failure" ]]; then
            echo "## âš ï¸ Environment Preparation Failed"
          elif [[ "${{ needs.validate.result }}" == "failure" ]]; then
            echo "## âš ï¸ Terraform Validation Failed"
          elif [[ "${{ needs.plan.result }}" == "failure" ]]; then
            echo "## âš ï¸ Terraform Plan Failed"
          elif [[ "${{ needs.apply.result }}" == "failure" ]]; then
            echo "## âš ï¸ Terraform Apply Failed"
          fi
          
          echo "Please check the logs for detailed error information."
          echo "Failure occurred at: $(date)"
          echo "::endgroup::"