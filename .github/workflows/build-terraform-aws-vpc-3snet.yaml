name: AWS-terraform-1-vpc-3-subnet
on:
  push:
    branches:
      - main

permissions:
  id-token: write # Required for AWS OIDC connection
  contents: read # Required for actions/checkout
  pull-requests: write # Required for GitHub bot to comment on PR
  issues: write # Required for posting plan results as issue comments

env:
  TF_LOG: INFO
  AWS_REGION: ${{ secrets.AWS_REGION }}
  TERRAFORM_VERSION: 1.11.0

jobs:
  terraform:
    name: 'AWS-terraform-1-vpc-3-subnet'
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: .
    
    steps:
    # ðŸ” PREPARATION PHASE - Repository checkout and environment setup
    - name: ðŸ” Checkout repository
      uses: actions/checkout@v4
      id: checkout
    
    - name: ðŸ”§ Setup Terraform
      uses: hashicorp/setup-terraform@v2
      id: setup
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

    - name: ðŸ” Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      id: aws-credentials
      with:
        role-to-assume: ${{ secrets.AWS_ROLE }}
        aws-region: ${{ secrets.AWS_REGION }}
        role-session-name: GitHubActions
    
    # ðŸš€ INITIALIZATION PHASE - Initialize and validate Terraform
    - name: ðŸš€ Initialize Terraform
      id: init
      working-directory: infrastructure
      run: |
        echo "::group::Terraform Initialization"
        echo "ðŸ”„ Starting Terraform initialization..."
        
        # Initialize with state migration enabled
        if terraform init -migrate-state; then
          echo "âœ… Terraform initialization successful"
          echo "init_status=success" >> $GITHUB_OUTPUT
        else
          echo "âŒ Terraform initialization failed"
          echo "init_status=failure" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "::endgroup::"

    - name: ðŸ” Validate Terraform Configuration
      id: validate
      working-directory: infrastructure
      if: steps.init.outputs.init_status == 'success'
      run: |
    

          echo "::group::Terraform Plan Generation"
          echo "ðŸ”„ Generating Terraform plan..."

          # Create plan file
          mkdir -p ./plans

          # Run plan and capture output
          if terraform plan -out=./plans/tfplan.binary -detailed-exitcode -input=false > ./plans/plan_output.txt 2>&1; then
            PLAN_EXIT_CODE=$?
            echo "âœ… Terraform plan generated successfully"
            echo "plan_status=success" >> $GITHUB_OUTPUT
            echo "plan_exitcode=${PLAN_EXIT_CODE}" >> $GITHUB_OUTPUT
            
            # Convert binary plan to JSON for easier parsing
            terraform show -json ./plans/tfplan.binary > ./plans/tfplan.json || echo "Warning: Unable to convert plan to JSON format"
            
            # Create human-readable summary
            echo "## Terraform Plan Summary" > ./plans/plan_summary.md
            echo "ðŸ“… Generated on: $(date)" >> ./plans/plan_summary.md
            echo "" >> ./plans/plan_summary.md
            
            # Count resources being added/changed/destroyed
            RESOURCES_ADD=$(grep -c "will be created" ./plans/plan_output.txt || echo "0")
            RESOURCES_CHANGE=$(grep -c "will be updated in-place" ./plans/plan_output.txt || echo "0")
            RESOURCES_DESTROY=$(grep -c "will be destroyed" ./plans/plan_output.txt || echo "0")
            
            echo "ðŸŸ¢ Resources to add: ${RESOURCES_ADD}" >> ./plans/plan_summary.md
            echo "ðŸŸ  Resources to change: ${RESOURCES_CHANGE}" >> ./plans/plan_summary.md
            echo "ðŸ”´ Resources to destroy: ${RESOURCES_DESTROY}" >> ./plans/plan_summary.md
            echo "" >> ./plans/plan_summary.md
            
            # Extract and organize resources by type
            echo "## ðŸ” Detailed Resource Changes" >> ./plans/plan_summary.md
            echo "" >> ./plans/plan_summary.md
            
            # Process resources to be created (additions)
            if [ "${RESOURCES_ADD}" -gt "0" ]; then
              echo "### ðŸŸ¢ Resources To Be Created" >> ./plans/plan_summary.md
              echo "" >> ./plans/plan_summary.md
              
              # Check if we can use the JSON method
              if [ -s "./plans/tfplan.json" ] && jq -e . ./plans/tfplan.json >/dev/null 2>&1; then
                # JSON is valid, use jq to extract resource information
                jq -r '.resource_changes[] | select(.change.actions[] == "create") | "\(.type).\(.name) (\(.address))"' ./plans/tfplan.json 2>/dev/null | sort | uniq > ./plans/resources_create.txt || echo "No resources found" > ./plans/resources_create.txt
                
                # Group resources by type
                current_type=""
                while IFS= read -r resource; do
                  # Skip empty lines or error messages
                  [[ -z "$resource" || "$resource" == "No resources found" ]] && continue
                
                  # Extract the resource type (everything before the first dot)
                  resource_type=$(echo "$resource" | cut -d'.' -f1)
                  
                  # If we have a new type, print a subheading
                  if [ "$resource_type" != "$current_type" ]; then
                    echo "#### $resource_type" >> ./plans/plan_summary.md
                    current_type="$resource_type"
                  fi
                  
                  # Get the resource address
                  resource_address=$(echo "$resource" | sed -E 's/.*\((.*)\)/\1/' || echo "$resource")
                  
                  # Extract key attributes if possible
                  echo "- \`$resource_address\`" >> ./plans/plan_summary.md
                  
                  # Try to extract some useful attributes for this resource (with fallback)
                  jq -r --arg addr "$resource_address" '.resource_changes[] | select(.address == $addr) | .change.after | to_entries | map("  - " + .key + ": " + (.value | tostring)) | .[]' ./plans/tfplan.json 2>/dev/null | grep -v "null" | grep -v '^\s*$' >> ./plans/plan_summary.md || echo "  - (Details not available)" >> ./plans/plan_summary.md
                done < ./plans/resources_create.txt
              else
                # Fallback to text-based extraction from plan output
                echo "#### Resources (extracted from text output)" >> ./plans/plan_summary.md
                
                # Pattern match for resources that will be created
                grep -A 1 "will be created" ./plans/plan_output.txt | grep -v "will be created" | grep -v "\-\-" | sed 's/^ *//g' | sed 's/^/- `/' | sed 's/$/`/' >> ./plans/plan_summary.md
              fi
              
              echo "" >> ./plans/plan_summary.md
            fi
            
            # Process resources to be updated (changes)
            if [ "${RESOURCES_CHANGE}" -gt "0" ]; then
              echo "### ðŸŸ  Resources To Be Updated" >> ./plans/plan_summary.md
              echo "" >> ./plans/plan_summary.md
              
              # Check if we can use the JSON method
              if [ -s "./plans/tfplan.json" ] && jq -e . ./plans/tfplan.json >/dev/null 2>&1; then
                # JSON is valid, use jq to extract resource information
                jq -r '.resource_changes[] | select(.change.actions[] == "update") | "\(.type).\(.name) (\(.address))"' ./plans/tfplan.json 2>/dev/null | sort | uniq > ./plans/resources_update.txt || echo "No resources found" > ./plans/resources_update.txt
                
                # Group resources by type
                current_type=""
                while IFS= read -r resource; do
                  # Skip empty lines or error messages
                  [[ -z "$resource" || "$resource" == "No resources found" ]] && continue
                
                  # Extract the resource type (everything before the first dot)
                  resource_type=$(echo "$resource" | cut -d'.' -f1)
                  
                  # If we have a new type, print a subheading
                  if [ "$resource_type" != "$current_type" ]; then
                    echo "#### $resource_type" >> ./plans/plan_summary.md
                    current_type="$resource_type"
                  fi
                  
                  # Get the resource address
                  resource_address=$(echo "$resource" | sed -E 's/.*\((.*)\)/\1/' || echo "$resource")
                  
                  # Show what's changing
                  echo "- \`$resource_address\`" >> ./plans/plan_summary.md
                  echo "  <details><summary>View changes</summary>" >> ./plans/plan_summary.md
                  echo "" >> ./plans/plan_summary.md
                  echo "  ```diff" >> ./plans/plan_summary.md
                  
                  # Try to extract change information, with fallback
                  if ! jq -r --arg addr "$resource_address" '.resource_changes[] | select(.address == $addr) | .change | .before as $before | .after as $after | $before | keys[] | select($before[.] != $after[.]) | "  - " + . + ": " + ($before[.] | tostring) + "\n  + " + . + ": " + ($after[.] | tostring)' ./plans/tfplan.json 2>/dev/null >> ./plans/plan_summary.md; then
                    echo "  # Change details could not be parsed" >> ./plans/plan_summary.md
                  fi
                  
                  echo "  ```" >> ./plans/plan_summary.md
                  echo "" >> ./plans/plan_summary.md
                  echo "  </details>" >> ./plans/plan_summary.md
                done < ./plans/resources_update.txt
              else
                # Fallback to text-based extraction from plan output
                echo "#### Resources (extracted from text output)" >> ./plans/plan_summary.md
                
                # Pattern match for resources that will be updated
                grep -A 1 "will be updated in-place" ./plans/plan_output.txt | grep -v "will be updated in-place" | grep -v "\-\-" | sed 's/^ *//g' | sed 's/^/- `/' | sed 's/$/`/' >> ./plans/plan_summary.md
              fi
              
              echo "" >> ./plans/plan_summary.md
            fi
            
            # Process resources to be destroyed
            if [ "${RESOURCES_DESTROY}" -gt "0" ]; then
              echo "### ðŸ”´ Resources To Be Destroyed" >> ./plans/plan_summary.md
              echo "" >> ./plans/plan_summary.md
              
              # Check if we can use the JSON method
              if [ -s "./plans/tfplan.json" ] && jq -e . ./plans/tfplan.json >/dev/null 2>&1; then
                # JSON is valid, use jq to extract resource information
                jq -r '.resource_changes[] | select(.change.actions[] == "delete") | "\(.type).\(.name) (\(.address))"' ./plans/tfplan.json 2>/dev/null | sort | uniq > ./plans/resources_destroy.txt || echo "No resources found" > ./plans/resources_destroy.txt
                
                # Group resources by type
                current_type=""
                while IFS= read -r resource; do
                  # Skip empty lines or error messages
                  [[ -z "$resource" || "$resource" == "No resources found" ]] && continue
                
                  # Extract the resource type (everything before the first dot)
                  resource_type=$(echo "$resource" | cut -d'.' -f1)
                  
                  # If we have a new type, print a subheading
                  if [ "$resource_type" != "$current_type" ]; then
                    echo "#### $resource_type" >> ./plans/plan_summary.md
                    current_type="$resource_type"
                  fi
                  
                  # Get the resource address
                  resource_address=$(echo "$resource" | sed -E 's/.*\((.*)\)/\1/' || echo "$resource")
                  
                  # Show basic info for soon-to-be-destroyed resources
                  echo "- \`$resource_address\`" >> ./plans/plan_summary.md
                done < ./plans/resources_destroy.txt
              else
                # Fallback to text-based extraction from plan output
                echo "#### Resources (extracted from text output)" >> ./plans/plan_summary.md
                
                # Pattern match for resources that will be destroyed
                grep -A 1 "will be destroyed" ./plans/plan_output.txt | grep -v "will be destroyed" | grep -v "\-\-" | sed 's/^ *//g' | sed 's/^/- `/' | sed 's/$/`/' >> ./plans/plan_summary.md
              fi
              
              echo "" >> ./plans/plan_summary.md
            fi
            
            # Add infrastructure diagram section if no changes
            if [ "${RESOURCES_ADD}" -eq "0" ] && [ "${RESOURCES_CHANGE}" -eq "0" ] && [ "${RESOURCES_DESTROY}" -eq "0" ]; then
              echo "### ðŸŸ¦ No Changes Detected" >> ./plans/plan_summary.md
              echo "" >> ./plans/plan_summary.md
              echo "No infrastructure changes were detected in this plan." >> ./plans/plan_summary.md
            fi
            
            # Add VPC and subnet specific section for this workflow
            echo "## ðŸŒ VPC & Subnet Configuration" >> ./plans/plan_summary.md
            echo "" >> ./plans/plan_summary.md
            
            # Check if we can use the JSON method
            if [ -s "./plans/tfplan.json" ] && jq -e . ./plans/tfplan.json >/dev/null 2>&1; then
              # Extract VPC details if present
              if VPC_COUNT=$(jq -r '.resource_changes[] | select(.type == "aws_vpc")' ./plans/tfplan.json 2>/dev/null | grep -c "address" || echo "0"); then
                if [ "${VPC_COUNT}" -gt "0" ]; then
                  echo "### Virtual Private Cloud Details" >> ./plans/plan_summary.md
                  if ! jq -r '.resource_changes[] | select(.type == "aws_vpc") | "- **VPC:** \(.address)\n  - CIDR: \(.change.after.cidr_block)\n  - DNS Support: \(.change.after.enable_dns_support)\n  - DNS Hostnames: \(.change.after.enable_dns_hostnames)"' ./plans/tfplan.json 2>/dev/null >> ./plans/plan_summary.md; then
                    # Fallback to simpler extraction
                    jq -r '.resource_changes[] | select(.type == "aws_vpc") | "- **VPC:** \(.address)"' ./plans/tfplan.json 2>/dev/null >> ./plans/plan_summary.md || echo "- VPC configuration detected (details unavailable)" >> ./plans/plan_summary.md
                  fi
                  echo "" >> ./plans/plan_summary.md
                fi
              fi
              
              # Extract subnet details if present
              if SUBNET_COUNT=$(jq -r '.resource_changes[] | select(.type == "aws_subnet")' ./plans/tfplan.json 2>/dev/null | grep -c "address" || echo "0"); then
                if [ "${SUBNET_COUNT}" -gt "0" ]; then
                  echo "### Subnet Configuration" >> ./plans/plan_summary.md
                  echo "" >> ./plans/plan_summary.md
                  echo "| Subnet | Availability Zone | CIDR Block | Public IP |" >> ./plans/plan_summary.md
                  echo "|--------|-------------------|------------|-----------|" >> ./plans/plan_summary.md
                  
                  if ! jq -r '.resource_changes[] | select(.type == "aws_subnet") | "\(.address) | \(.change.after.availability_zone // "default") | \(.change.after.cidr_block) | \(.change.after.map_public_ip_on_launch // false)"' ./plans/tfplan.json 2>/dev/null | while read -r line; do
                    echo "| \`${line/ | / | \`}" | sed 's/| false$/| âŒ|/g' | sed 's/| true$/| âœ…|/g' >> ./plans/plan_summary.md
                  done; then
                    # Fallback to simpler extraction
                    jq -r '.resource_changes[] | select(.type == "aws_subnet") | "| `\(.address)` | (details unavailable) | (details unavailable) | - |"' ./plans/tfplan.json 2>/dev/null >> ./plans/plan_summary.md || echo "| Subnet details unavailable | - | - | - |" >> ./plans/plan_summary.md
                  fi
                  
                  echo "" >> ./plans/plan_summary.md
                fi
              fi
            else
              # Fallback for text-based extraction
              # Look for VPC and subnet information in the plan output
              echo "### Infrastructure Details (extracted from text output)" >> ./plans/plan_summary.md
              
              # Extract VPC info if available
              if grep -q "aws_vpc" ./plans/plan_output.txt; then
                echo "#### VPC Resources" >> ./plans/plan_summary.md
                grep -A 5 "aws_vpc" ./plans/plan_output.txt | grep -v "\-\-" | sed 's/^ *//g' >> ./plans/plan_summary.md
                echo "" >> ./plans/plan_summary.md
              fi
              
              # Extract subnet info if available
              if grep -q "aws_subnet" ./plans/plan_output.txt; then
                echo "#### Subnet Resources" >> ./plans/plan_summary.md
                grep -A 5 "aws_subnet" ./plans/plan_output.txt | grep -v "\-\-" | sed 's/^ *//g' >> ./plans/plan_summary.md
                echo "" >> ./plans/plan_summary.md
              fi
            fi
            
            # Add link to full plan output
            echo "## ðŸ“‹ Full Plan Details" >> ./plans/plan_summary.md
            echo "" >> ./plans/plan_summary.md
            echo "For complete details, see the [full plan output](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID})." >> ./plans/plan_summary.md
            
            # Display the summary in the GitHub Actions log
            cat ./plans/plan_summary.md
          else
            echo "âŒ Terraform plan generation failed"
            echo "plan_status=failure" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "::endgroup::"